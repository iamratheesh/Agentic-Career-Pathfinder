# career_pathfinder/routes/career.py

from fastapi import APIRouter, HTTPException
from motor.motor_asyncio import AsyncIOMotorClient
from database import get_database
# MODIFIED: Import FullCareerTrack for the response model, as it contains trackId
from models import CareerTrack, SessionDocument, CareerTrackDocument, FullCareerTrack
from agents.track_recommender import CareerTrackRecommenderAgent
from config import settings
from typing import List
from bson import ObjectId

router = APIRouter()

# MODIFIED: Response model changed to List[FullCareerTrack]
@router.get("/career-tracks/{session_id}", response_model=List[FullCareerTrack])
async def get_career_tracks(session_id: str):
    """
    Generates and returns career track recommendations based on user's domain and skill level.
    """
    db = get_database()

    # Get domain + level from session
    session_doc = await db.Session.find_one({"_id": ObjectId(session_id)})
    if not session_doc:
        raise HTTPException(status_code=404, detail="Session not found")
    if not session_doc.get("level"):
        raise HTTPException(status_code=400, detail="User level not yet determined. Complete the quiz first.")

    domain = session_doc["domain"]
    level = session_doc["level"]

    # Use domain + level to generate 2-3 career tracks using agent
    recommender_agent = CareerTrackRecommenderAgent(
        api_key=settings.GROQ_API_KEY,
        tavily_api_key=settings.TAVILY_API_KEY
    )
    
    try:
        # This returns a list of dictionaries generated by the LLM, without _id yet
        llm_recommended_tracks = await recommender_agent.recommend_tracks(domain, level)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to generate career tracks due to agent error: {e}")

    if not llm_recommended_tracks:
        raise HTTPException(status_code=500, detail="Failed to generate any career tracks. Agent returned empty list.")

    # Store recommended tracks. For upsert, MongoDB creates _id if new.
    for track_data in llm_recommended_tracks:
        # Create a Pydantic model instance from the track data
        track_doc = CareerTrackDocument(sessionId=session_id, **track_data)
        
        # Use update_one with upsert=True to either insert or replace the track.
        # This operation will either create a new _id or use an existing one.
        await db.CareerTrack.update_one(
            {"sessionId": session_id, "title": track_data["title"]}, # Filter by session and title to prevent duplicates for the same session
            {"$set": track_doc.model_dump(by_alias=True, exclude_none=True)}, # Ensure Pydantic V2 model_dump() is used
            upsert=True # If no matching document is found, a new one is inserted
        )

    # *** CRITICAL FIX: Fetch the career tracks from the DB after saving/upserting ***
    # This ensures we retrieve the MongoDB _id for each track.
    fetched_career_tracks_cursor = db.CareerTrack.find({"sessionId": session_id})
    fetched_career_tracks_data = await fetched_career_tracks_cursor.to_list(length=None)

    # Convert the fetched MongoDB documents (which now include '_id') into FullCareerTrack models
    # FullCareerTrack has 'trackId: str = Field(alias="_id")' which correctly captures the _id.
    response_tracks = []
    for track_doc_data in fetched_career_tracks_data:
        # Use FullCareerTrack directly as it aligns with what we need to return
        # It handles aliasing _id to trackId automatically from MongoDB dicts
        response_tracks.append(FullCareerTrack(**track_doc_data))

    return response_tracks